<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Drawing Tool</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            user-select: none;
            gap: 20px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 150px;
            position: fixed;
            left: 20px;
            top: 20px;
        }

        .canvas-container {
            position: relative;
            border: 1px solid #ccc;
            background: white;
            margin: 0 auto;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            cursor: none;
            width: 100%;
            height: 100%;
        }

        button {
            padding: 8px 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="exportPNG">Export PNG</button>
        <button id="exportSVG">Export SVG</button>
        <button id="exportJSON">Export JSON</button>
        <button id="exportAll">Export All</button>
        <button id="clearBackground" style="display: none;">Clear Background</button>
        <button id="invertColors">Invert Colors</button>
    </div>
    <div class="canvas-container" id="canvasContainer">
        <canvas id="baseCanvas"></canvas>
        <canvas id="overlayCanvas"></canvas>
    </div>

    <script>
        const GRID_SIZE = 26;
        const EXPORT_PIXEL_SIZE = 12;
        let pixelSize = 32;
        let canvasSize = GRID_SIZE * pixelSize;

        const grid = Array(GRID_SIZE).fill(null).map(() => 
            Array(GRID_SIZE).fill(null).map(() => 'clear')
        );

        const baseCanvas = document.getElementById('baseCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const canvasContainer = document.getElementById('canvasContainer');
        let backgroundImage = null;
        let drawingState = {
            isDrawing: false,
            hoverRegion: null
        };
        let drawingMode = 'black';
        let lastPosition = null;
        let previousPosition = null;
        let hoverPosition = null;
        let mousePosition = null;
        let keyboardPosition = null;

        function updatePixelSize() {
            const windowHeight = window.innerHeight;
            pixelSize = Math.floor((windowHeight - 100) / GRID_SIZE);
            canvasSize = GRID_SIZE * pixelSize;
            canvasContainer.style.width = `${canvasSize}px`;
            canvasContainer.style.height = `${canvasSize}px`;
            baseCanvas.width = canvasSize;
            baseCanvas.height = canvasSize;
            overlayCanvas.width = canvasSize;
            overlayCanvas.height = canvasSize;
            drawBase();
        }

        function drawBase() {
            const ctx = baseCanvas.getContext('2d');
            if (!ctx) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvasSize, canvasSize);

            // Draw white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            // Draw background image if exists
            if (backgroundImage) {
                ctx.globalAlpha = 0.5;
                ctx.drawImage(backgroundImage, 0, 0, canvasSize, canvasSize);
                ctx.globalAlpha = 1;
            }

            // Draw grid lines
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;

            // Draw vertical lines
            ctx.beginPath();
            for (let i = 0; i <= GRID_SIZE; i++) {
                const x = i * pixelSize - 0.5;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasSize);
            }
            ctx.stroke();

            // Draw horizontal lines
            ctx.beginPath();
            for (let i = 0; i <= GRID_SIZE; i++) {
                const y = i * pixelSize - 0.5;
                ctx.moveTo(0, y);
                ctx.lineTo(canvasSize, y);
            }
            ctx.stroke();

            // Draw grid content
            ctx.fillStyle = 'black';
            grid.forEach((row, i) => {
                row.forEach((pixel, j) => {
                    const x = j * pixelSize;
                    const y = i * pixelSize;

                    if (pixel === 'black') {
                        ctx.fillRect(x, y, pixelSize, pixelSize);
                    } else if (pixel !== 'clear') {
                        ctx.beginPath();
                        switch (pixel) {
                            case 'top-left':
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + pixelSize);
                                ctx.lineTo(x + pixelSize, y);
                                break;
                            case 'top-right':
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + pixelSize, y);
                                ctx.lineTo(x + pixelSize, y + pixelSize);
                                break;
                            case 'bottom-left':
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + pixelSize);
                                ctx.lineTo(x + pixelSize, y + pixelSize);
                                break;
                            case 'bottom-right':
                                ctx.moveTo(x + pixelSize, y);
                                ctx.lineTo(x, y + pixelSize);
                                ctx.lineTo(x + pixelSize, y + pixelSize);
                                break;
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            });
        }

        function drawOverlay() {
            const ctx = overlayCanvas.getContext('2d');
            if (!ctx) return;

            ctx.clearRect(0, 0, canvasSize, canvasSize);

            if (hoverPosition) {
                const x = hoverPosition.col * pixelSize;
                const y = hoverPosition.row * pixelSize;
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';

                const region = drawingState.isDrawing ? drawingMode : hoverPosition.region;

                if (region === 'black' || region === 'center' || region === 'clear') {
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                } else {
                    ctx.beginPath();
                    switch (region) {
                        case 'top-left':
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y + pixelSize);
                            ctx.lineTo(x + pixelSize, y);
                            break;
                        case 'top-right':
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + pixelSize, y);
                            ctx.lineTo(x + pixelSize, y + pixelSize);
                            break;
                        case 'bottom-left':
                            ctx.moveTo(x, y);
                            ctx.lineTo(x, y + pixelSize);
                            ctx.lineTo(x + pixelSize, y + pixelSize);
                            break;
                        case 'bottom-right':
                            ctx.moveTo(x + pixelSize, y);
                            ctx.lineTo(x, y + pixelSize);
                            ctx.lineTo(x + pixelSize, y + pixelSize);
                            break;
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }

            if (mousePosition) {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(mousePosition.x, mousePosition.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function getMousePosition(e) {
            const rect = baseCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const col = Math.floor(x / pixelSize);
            const row = Math.floor(y / pixelSize);

            if (col < 0 || col >= GRID_SIZE || row < 0 || row >= GRID_SIZE) {
                return null;
            }

            const cellX = (x % pixelSize) / pixelSize;
            const cellY = (y % pixelSize) / pixelSize;

            let region;
            if (cellX + cellY < 0.5) {
                region = 'top-left';
            } else if (cellX + cellY > 1.5) {
                region = 'bottom-right';
            } else if (cellX - cellY > 0.5) {
                region = 'top-right';
            } else if (cellY - cellX > 0.5) {
                region = 'bottom-left';
            } else {
                region = 'center';
            }

            return { row, col, region };
        }

        function handleMouseDown(e) {
            const pos = getMousePosition(e);
            if (!pos) return;

            drawingState.isDrawing = true;
            drawingState.hoverRegion = pos.region;
            lastPosition = pos;
            previousPosition = pos;
            hoverPosition = pos;

            let state = pos.region === 'center' ? 'black' : pos.region;
            updatePixel(pos.row, pos.col, state);
        }

        function handleMouseMove(e) {
            const rect = baseCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            mousePosition = { x, y };

            const pos = getMousePosition(e);
            if (!pos) return;

            if (drawingState.isDrawing && previousPosition) {
                hoverPosition = { ...pos, region: lastPosition?.region || pos.region };
                
                let state = lastPosition?.region === 'center' ? 'black' : (lastPosition?.region || pos.region);

                bresenhamLine(
                    previousPosition.col,
                    previousPosition.row,
                    pos.col,
                    pos.row,
                    (x, y) => {
                        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                            updatePixel(y, x, state);
                        }
                    }
                );
                previousPosition = pos;
            } else {
                hoverPosition = pos;
            }
            drawOverlay();
        }

        function handleMouseUp() {
            drawingState.isDrawing = false;
            lastPosition = null;
            previousPosition = null;
        }

        function handleMouseLeave() {
            hoverPosition = null;
            mousePosition = null;
            drawOverlay();
        }

        function updatePixel(row, col, state = 'black') {
            grid[row][col] = state;
            drawBase();
        }

        function bresenhamLine(x0, y0, x1, y1, callback) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                callback(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        function generateHash(content) {
            const str = JSON.stringify(content);
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16).slice(0, 8);
        }

        function exportAsPNG() {
            const hash = generateHash(grid);
            const exportCanvas = document.createElement('canvas');
            const exportSize = GRID_SIZE * 32;
            exportCanvas.width = exportSize;
            exportCanvas.height = exportSize;
            const ctx = exportCanvas.getContext('2d');
            if (!ctx) return;

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, exportSize, exportSize);

            grid.forEach((row, i) => {
                row.forEach((pixel, j) => {
                    const x = j * 32;
                    const y = i * 32;

                    if (pixel === 'black') {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(x, y, 32, 32);
                    } else if (pixel !== 'clear') {
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        switch (pixel) {
                            case 'top-left':
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + 32);
                                ctx.lineTo(x + 32, y);
                                break;
                            case 'top-right':
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + 32, y);
                                ctx.lineTo(x + 32, y + 32);
                                break;
                            case 'bottom-left':
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + 32);
                                ctx.lineTo(x + 32, y + 32);
                                break;
                            case 'bottom-right':
                                ctx.moveTo(x + 32, y);
                                ctx.lineTo(x, y + 32);
                                ctx.lineTo(x + 32, y + 32);
                                break;
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            });

            const link = document.createElement('a');
            link.download = `${hash}.png`;
            link.href = exportCanvas.toDataURL();
            link.click();
        }

        function exportAsSVG() {
            const hash = generateHash(grid);
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            const exportSize = GRID_SIZE * EXPORT_PIXEL_SIZE;
            svg.setAttribute('width', `${exportSize}`);
            svg.setAttribute('height', `${exportSize}`);
            svg.setAttribute('viewBox', `0 0 ${exportSize} ${exportSize}`);

            grid.forEach((row, i) => {
                row.forEach((pixel, j) => {
                    if (pixel === 'black') {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', `${j * EXPORT_PIXEL_SIZE}`);
                        rect.setAttribute('y', `${i * EXPORT_PIXEL_SIZE}`);
                        rect.setAttribute('width', `${EXPORT_PIXEL_SIZE}`);
                        rect.setAttribute('height', `${EXPORT_PIXEL_SIZE}`);
                        rect.setAttribute('fill', 'black');
                        svg.appendChild(rect);
                    } else if (pixel !== 'clear') {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const points = {
                            'top-left': `M${j * EXPORT_PIXEL_SIZE},${i * EXPORT_PIXEL_SIZE} L${j * EXPORT_PIXEL_SIZE},${(i + 1) * EXPORT_PIXEL_SIZE} L${(j + 1) * EXPORT_PIXEL_SIZE},${i * EXPORT_PIXEL_SIZE} Z`,
                            'top-right': `M${j * EXPORT_PIXEL_SIZE},${i * EXPORT_PIXEL_SIZE} L${(j + 1) * EXPORT_PIXEL_SIZE},${i * EXPORT_PIXEL_SIZE} L${(j + 1) * EXPORT_PIXEL_SIZE},${(i + 1) * EXPORT_PIXEL_SIZE} Z`,
                            'bottom-left': `M${j * EXPORT_PIXEL_SIZE},${i * EXPORT_PIXEL_SIZE} L${j * EXPORT_PIXEL_SIZE},${(i + 1) * EXPORT_PIXEL_SIZE} L${(j + 1) * EXPORT_PIXEL_SIZE},${(i + 1) * EXPORT_PIXEL_SIZE} Z`,
                            'bottom-right': `M${(j + 1) * EXPORT_PIXEL_SIZE},${(i + 1) * EXPORT_PIXEL_SIZE} L${j * EXPORT_PIXEL_SIZE},${(i + 1) * EXPORT_PIXEL_SIZE} L${(j + 1) * EXPORT_PIXEL_SIZE},${i * EXPORT_PIXEL_SIZE} Z`,
                        };
                        path.setAttribute('d', points[pixel]);
                        path.setAttribute('fill', 'black');
                        svg.appendChild(path);
                    }
                });
            });

            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = `${hash}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportAsJSON() {
            const hash = generateHash(grid);
            const exportData = {
                version: 1,
                grid: grid
            };
            const blob = new Blob([JSON.stringify(exportData)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `${hash}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportAll() {
            exportAsPNG();
            exportAsSVG();
            exportAsJSON();
        }

        function handleFileDrop(e) {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file) {
                if (file.type === 'application/json') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const loadedData = JSON.parse(event.target?.result);
                            const loadedGrid = loadedData.version === 1 ? loadedData.grid : loadedData;
                            grid.splice(0, grid.length, ...loadedGrid);
                            drawBase();
                        } catch (error) {
                            console.error('Error loading file:', error);
                        }
                    };
                    reader.readAsText(file);
                } else if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            backgroundImage = img;
                            document.getElementById('clearBackground').style.display = 'block';
                            drawBase();
                        };
                        img.src = event.target?.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
        }

        function clearBackground() {
            backgroundImage = null;
            document.getElementById('clearBackground').style.display = 'none';
            drawBase();
        }

        function invertPixels() {
            const newGrid = grid.map(row =>
                row.map(pixel => {
                    if (pixel === 'clear') {
                        return 'black';
                    } else if (pixel === 'black') {
                        return 'clear';
                    } else {
                        const inverted = {
                            'top-left': 'bottom-right',
                            'top-right': 'bottom-left',
                            'bottom-left': 'top-right',
                            'bottom-right': 'top-left'
                        }[pixel];
                        return inverted;
                    }
                })
            );
            grid.splice(0, grid.length, ...newGrid);
            drawBase();
        }

        // Event Listeners
        baseCanvas.addEventListener('mousedown', handleMouseDown);
        baseCanvas.addEventListener('mousemove', handleMouseMove);
        baseCanvas.addEventListener('mouseup', handleMouseUp);
        baseCanvas.addEventListener('mouseleave', handleMouseLeave);
        overlayCanvas.addEventListener('mousedown', handleMouseDown);
        overlayCanvas.addEventListener('mousemove', handleMouseMove);
        overlayCanvas.addEventListener('mouseup', handleMouseUp);
        overlayCanvas.addEventListener('mouseleave', handleMouseLeave);

        document.addEventListener('keydown', (e) => {
            if (!hoverPosition) return;
            
            const key = e.key.toLowerCase();
            let mode = null;
            
            switch (key) {
                case 'z':
                    mode = 'black';
                    break;
                case 'x':
                    mode = 'clear';
                    break;
                case 'q':
                    mode = 'bottom-right';
                    break;
                case 'w':
                    mode = 'bottom-left';
                    break;
                case 'a':
                    mode = 'top-right';
                    break;
                case 's':
                    mode = 'top-left';
                    break;
            }

            if (mode !== null) {
                drawingState.isDrawing = true;
                drawingMode = mode;
                keyboardPosition = { row: hoverPosition.row, col: hoverPosition.col };
                updatePixel(hoverPosition.row, hoverPosition.col, mode);
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (['z', 'x', 'q', 'w', 'a', 's'].includes(key)) {
                drawingState.isDrawing = false;
                keyboardPosition = null;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (drawingState.isDrawing && keyboardPosition && hoverPosition) {
                bresenhamLine(
                    keyboardPosition.col,
                    keyboardPosition.row,
                    hoverPosition.col,
                    hoverPosition.row,
                    (x, y) => {
                        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                            updatePixel(y, x, drawingMode);
                        }
                    }
                );
                keyboardPosition = { row: hoverPosition.row, col: hoverPosition.col };
            }
        });

        document.getElementById('exportPNG').addEventListener('click', exportAsPNG);
        document.getElementById('exportSVG').addEventListener('click', exportAsSVG);
        document.getElementById('exportJSON').addEventListener('click', exportAsJSON);
        document.getElementById('exportAll').addEventListener('click', exportAll);
        document.getElementById('clearBackground').addEventListener('click', clearBackground);
        document.getElementById('invertColors').addEventListener('click', invertPixels);

        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', handleFileDrop);

        // Initialize
        updatePixelSize();
        window.addEventListener('resize', updatePixelSize);
    </script>
</body>
</html> 